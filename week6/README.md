

## 1. 临界区（Critical Section）
- **定义**：访问共享资源的代码片段。
- **必要性**：避免竞态、数据撕裂、死锁。
- **常见手段**：自旋锁（不可睡眠）、互斥锁（可睡眠）、关中断、原子操作。

## 2. 抢占模型
- **Non-Preemptive**：内核态不可被打断；实现简单、尾时延大。
- **Preemptive（默认）**：内核可被更高优先级打断（除非禁抢或持自旋锁）；延迟更低。
- **PREEMPT_RT**：中断线程化，自旋锁大量转为 **rt-mutex**；最低抖动，对“可睡眠/不可睡眠”边界要求严格。

## 3. 避免自旋锁死锁（实践）
- **统一锁序**：遵循固定获取顺序，禁止环形等待。
- **持锁不睡眠**：自旋锁内禁止 `copy_*_user`、`kmalloc(GFP_KERNEL)` 等可能睡眠操作。
- **中断语义匹配**：使用 `spin_lock_irqsave/irqrestore` 防止中断重入拿同锁。
- **缩短临界区**：只做 O(1) 更新；重活放到互斥锁/工作队列/线程。
- **减少共享**：per-CPU、RCU、seqcount 等读多写少方案。
- **诊断**：开启 lockdep 报告潜在死锁。

## 4. 内存管理“三大件”
1. **`struct page`（memmap）**：物理页元数据。  
2. **Zone / 伙伴系统（Buddy）**：按 2^order 页块分裂/合并，页级分配后端。  
3. **Slab 系列（SLAB/SLUB/SLOB）**：小对象缓存；`kmalloc` 背后通常走 SLUB 的通用缓存。

## 5. 伙伴系统（Buddy System）
- **思路**：空闲内存以 2^order 页块管理；分配→分裂，释放→尝试与伙伴合并。
- **优点**：降低外部碎片，给页表映射、SLAB、`vmalloc` 提供页。

## 6. Slab/SLUB 与 kmalloc/vmalloc
- **Slab/SLUB**：对象缓存，快速分配、提升缓存局部性；SLUB 为现代默认。
- **`kmalloc(n, GFP_*)`**：来自 kmalloc-* 缓存；**物理连续**、缓存友好；适合小到中等尺寸、可用于 DMA。
- **`vmalloc(n)`**：**虚拟连续**，物理可不连续；开销更大，不适合 DMA；用于大块内存/模块大数组。

## 7. Cache “着色”（cache coloring）
- **目的**：历史上为避免 VIPT L1 同义/索引冲突、降低冲突未命中与伪共享。
- **现状**：现代 x86 基本无需显式操心；SLUB 已做 cacheline 对齐与随机化。布局热点字段时注意 **cacheline** 对齐即可。

## 8. 从 `malloc()` 到内核发生了什么
- **用户态**：`malloc` 维护堆；大块多用 `mmap`；触碰页触发缺页异常。
- **内核态处理**：缺页处理从伙伴系统分配物理页，清零并建立页表（匿名页）；或映射文件页缓存。
- **区别**：`kmalloc/vmalloc` 是**内核态**分配；用户态 `malloc` 仅在用户虚拟地址空间，二者只在用户拷贝/缺页时交集。

